#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 5.2
#  in conjunction with Tcl version 8.6
#    May 12, 2020 07:59:56 PM CEST  platform: Windows NT

import sys

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk

    py3 = False
except ImportError:
    import tkinter.ttk as ttk

    py3 = True

import os
import cv2
import numpy as np
from PIL import Image, ImageTk
# from wordcloud import WordCloud
from random import Random
import keyboard
import threading

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator, FormatStrFormatter
import matplotlib.animation as animation
from matplotlib import style

import gui_support
import datetime
import shared
import inspect  # To clean up multi-line strings. They introduce tabs on a new line.

style.use('ggplot')


class GUI(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.start()

    def callback(self):
        self.root.quit()

    def run(self):
        self.root = main_window()
        self.root.protocol("WM_DELETE_WINDOW", self.callback)
        print("Initialising GUI.")
        self.root.mainloop()


class overlay_window(tk.Toplevel):

    def __init__(self):
        tk.Toplevel.__init__(self)
        self.overrideredirect(True)  # Removes title bar
        self.geometry("100x140+0+100")
        self.resizable(0, 0)
        self.title("FER Overlay")
        self.configure(bg='#eeeeee')
        self.wm_attributes('-transparentcolor', '#eeeeee')
        self.visible = True
        self.wm_attributes("-topmost", 1)  # Keep window on top, always.

        self.emotion_img_ref = {emotion: Image.open('emotions/{}.png'.format(emotion)) \
                                for emotion in shared.emotion_names}  # As reference, otherwise images disappear...
        self.emotion_images_tk = {emotion: ImageTk.PhotoImage(img) \
                                  for emotion, img in self.emotion_img_ref.items()}  # These can be used.

        # self.webcam_img = tk.Label(self)
        # self.webcam_img.place(x=0, y=0, width=100, height=100)
        # self.webcam_img.configure(bg='#eeeeee', bd=0, padx=10, pady=10)

        self.emotion_text = tk.Label(self)
        self.emotion_text.place(x=0, y=100, width=100, height=40)
        self.emotion_text.configure(bg='#eeeeee')

        print('Overlay created.')

        self.update_overlay()

    def toggle(self):
        if self.visible:
            self.update()  # Tkinter's update
            self.withdraw()  # Hide the window
            self.visible = False
            shared.overlay_visible = False
            try:
                self.after_cancel(self.cancel)
            except:
                pass
            print('Hiding overlay.')
        else:
            self.update()  # Tkinter's update
            self.deiconify()  # Shows the widget and gives it focus.
            self.visible = True
            shared.overlay_visible = True
            self.update_overlay()
            print('Show overlay.')

    def update_overlay(self):
        if shared.system_state != shared.State.ACTIVE:
            self.cancel = self.after(1000, self.update_overlay)
            return

        emotion = shared.current_emotion
        # webcam = shared.webcam_image
        # if webcam is not None:
            # It would be best to resize the output to fit, but PIL is bugged.
            # self.webcam_img.configure(image=shared.webcam_image)
        if emotion is not None:
            self.emotion_text.configure(image=self.emotion_images_tk[emotion])
        self.cancel = self.after(500, self.update_overlay)


class main_window(tk.Tk):
    bar_fig = Figure(figsize=(5, 5), dpi=100)
    bar_ax = bar_fig.add_subplot()
    cloud_fig = Figure(figsize=(5, 5), dpi=100)
    cloud_ax = cloud_fig.add_subplot()
    cloud_ax.axis('off')
    log_list = []

    description = {
        "Date": datetime.datetime.now().strftime('%d %B %Y'),
        "Time": datetime.datetime.now().strftime('%H:%M:%S'),
        "Duration": "00:00:00",
        "Overlay": 'True',
    }

    def __init__(self):
        tk.Tk.__init__(self)
        # Automatically generated
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'

        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.configure('.', font="TkDefaultFont")
        self.style.map('.', background=
        [('selected', _compcolor), ('active', _ana2color)])

        self.geometry("1280x720+373+188")
        self.minsize(120, 1)
        self.maxsize(3844, 1061)
        self.resizable(0, 0)
        self.title("Facial Expression Recognition v0.1 - By Jeroen Ritmeester")
        self.configure(background="#d9d9d9")
        self.configure(highlightbackground="#d9d9d9")
        self.configure(highlightcolor="black")

        # Bar chart container
        self.fBars = tk.LabelFrame(self)
        self.fBars.place(relx=0.0, rely=0.1, relheight=0.4, relwidth=0.5)
        self.fBars.configure(relief='groove')
        self.fBars.configure(font=('Bahnschrift', 12))
        self.fBars.configure(foreground="black")
        self.fBars.configure(text='''Confidence per emotion''')
        self.fBars.configure(background="#ffffff")
        self.fBars.configure(highlightbackground="#d9d9d9")
        self.fBars.configure(highlightcolor="black")
        self.fBars.configure(padx="10")

        # Webcam container
        self.fWebcam = tk.LabelFrame(self)
        self.fWebcam.place(relx=0.5, rely=0.1, relheight=0.4, relwidth=0.3)
        self.fWebcam.configure(relief='groove')
        self.fWebcam.configure(font=('Bahnschrift', 12))
        self.fWebcam.configure(foreground="black")
        self.fWebcam.configure(text='''Webcam''')
        self.fWebcam.configure(background="#ffffff")
        self.fWebcam.configure(highlightbackground="#d9d9d9")
        self.fWebcam.configure(highlightcolor="black")

        self.webcamViewLabel = tk.Label(self.fWebcam)
        self.webcamViewLabel.pack()

        # Buttom right section
        self.fSummary = tk.LabelFrame(self)
        self.fSummary.place(relx=0.5, rely=0.5, relheight=0.5, relwidth=0.5)
        self.fSummary.configure(relief='groove')
        self.fSummary.configure(font=('Bahnschrift', 12))
        self.fSummary.configure(background="#ffffff")
        self.fSummary.configure(text='''Summary so far''')

        # Text container
        self.msgDescription = tk.Message(self.fSummary)
        self.msgDescription.place(x=270, y=18, height=95, width=300, bordermode='ignore')
        self.msgDescription.configure(anchor='nw')
        self.msgDescription.configure(background="#ffffff")
        self.msgDescription.configure(font=('Bahnschrift', 12))
        self.msgDescription.configure(foreground="black")
        self.msgDescription.configure(padx="20")
        self.msgDescription.configure(pady="0")
        self.msgDescription.configure(width=300)

        self.msgHotkeys = tk.Message(self.fSummary)
        self.msgHotkeys.place(x=270, y=125, height=120, width=300, bordermode='ignore')
        self.msgHotkeys.configure(anchor='nw')
        self.msgHotkeys.configure(background="#ffffff")
        self.msgHotkeys.configure(font=('Bahnschrift', 12))
        self.msgHotkeys.configure(foreground="black")
        self.msgHotkeys.configure(padx="20")
        self.msgHotkeys.configure(pady="0")
        hotkey_text = '''
        Press Control+F6 while in game to bring up this screen.
        Press Control+F7 to start/stop a recording.
        Press Control+F8 to toggle the overlay.
        Note that hotkey actions may perform slowly due to high workload.'''
        hotkey_text = inspect.cleandoc(hotkey_text)
        self.msgHotkeys.configure(text=hotkey_text)

        # Directory / Table with totals
        self.style.configure('Treeview', rowheight=44)
        self.table = ttk.Treeview(self.fSummary)
        self.table.place(relx=0.016, rely=0.056, relheight=0.928
                         , relwidth=0.4, bordermode='ignore')
        self.table["columns"] = ("one", "two")
        self.table.column("#0", width=127, minwidth=127, stretch=tk.NO)
        self.table.column("one", width=127, minwidth=127, stretch=tk.NO)
        self.table.heading("#0", text="Emotions", anchor=tk.W)
        self.table.heading("one", text="Total %", anchor=tk.W)

        # The live updated summary of emotions over time.
        # self.fWordcloud = tk.LabelFrame(self)
        # self.fWordcloud.place(relx=0.0, rely=0.5, relheight=0.5, relwidth=0.5)
        # self.fWordcloud.configure(relief='groove')
        # self.fWordcloud.configure(font=('Bahnschrift', 12))
        # self.fWordcloud.configure(foreground="black")
        # self.fWordcloud.configure(background="#ffffff")
        # self.fWordcloud.configure(highlightbackground="#d9d9d9")
        # self.fWordcloud.configure(highlightcolor="black")
        # self.fWordcloud.configure(text='''Wordcloud''')

        # Previous logs section
        self.fLogs = tk.LabelFrame(self)
        self.fLogs.place(relx=0.797, rely=0.1, relheight=0.4, relwidth=0.2)
        self.fLogs.configure(relief='groove')
        self.fLogs.configure(font=('Bahnschrift', 12))
        self.fLogs.configure(foreground="black")
        self.fLogs.configure(background="#ffffff")
        self.fLogs.configure(highlightbackground="#d9d9d9")
        self.fLogs.configure(highlightcolor="black")
        self.fLogs.configure(text='''Logs''')

        self.style.configure('Treeview', rowheight=40)
        self.log_list_widget = ttk.Treeview(self.fLogs, columns=('Time', 'Duration'))
        self.log_list_widget.place(relx=0.04, rely=0.1, relheight=0.86
                                   , relwidth=0.92, bordermode='ignore')
        self.log_list_widget.heading("#0", text="Date")
        self.log_list_widget.heading("#1", text="Time")
        self.log_list_widget.heading("#2", text="Duration")
        self.log_list_widget.column("#0", width=78, stretch=tk.YES)
        self.log_list_widget.column("#1", width=78, stretch=tk.YES)
        self.log_list_widget.column("#2", width=78, stretch=tk.YES)

        # TOP MENU
        self.Topbar = tk.Frame(self)
        self.Topbar.place(relx=0.0, rely=0.0, relheight=0.1, relwidth=1.0)
        self.Topbar.configure(background="#ffffff")
        self.Topbar.configure(highlightbackground="#f0f0f0f0f0f0")
        self.Topbar.configure(highlightcolor="black")

        self.btnPlay = tk.Button(self.Topbar)
        self.btnPlay.place(relx=0.008, rely=0.139, height=50, width=50)
        self.btnPlay.configure(activebackground="#d0d0d0")
        self.btnPlay.configure(activeforeground="#000000")
        self.btnPlay.configure(background="#ececec")
        self.btnPlay.configure(cursor="hand2")
        self.btnPlay.configure(disabledforeground="#a3a3a3")
        self.btnPlay.configure(font=('Bahnschrift', 10))
        self.btnPlay.configure(foreground="#000000")
        self.btnPlay.configure(highlightbackground="#ececec")
        self.btnPlay.configure(highlightcolor="black")
        self.btnPlay.configure(pady="0")
        self.btnPlay.configure(text='''Play''')
        self.btnPlay.configure(state=tk.DISABLED)
        self.tooltip_font = "TkDefaultFont"
        self.btnPlay_tooltip = \
            ToolTip(self.btnPlay, self.tooltip_font, '''Start the emotion recognition system.''')

        self.btnPause = tk.Button(self.Topbar)
        self.btnPause.place(relx=0.055, rely=0.139, height=50, width=50)
        self.btnPause.configure(activebackground="#d0d0d0")
        self.btnPause.configure(activeforeground="#000000")
        self.btnPause.configure(background="#ececec")
        self.btnPause.configure(cursor="hand2")
        self.btnPause.configure(disabledforeground="#a3a3a3")
        self.btnPause.configure(font=('Bahnschrift', 10))
        self.btnPause.configure(foreground="#000000")
        self.btnPause.configure(highlightbackground="#ececec")
        self.btnPause.configure(highlightcolor="black")
        self.btnPause.configure(pady="0")
        self.btnPause.configure(text='''Pause''')
        self.btnPause.configure(state=tk.DISABLED)
        self.btnPause_tooltip = \
            ToolTip(self.btnPause, self.tooltip_font, '''Pause the system, but don't reset the dashboard.''')

        self.btnRec = tk.Button(self.Topbar)
        self.btnRec.place(relx=0.148, rely=0.139, height=50, width=50)
        self.btnRec.configure(activebackground="#d0d0d0")
        self.btnRec.configure(activeforeground="#000000")
        self.btnRec.configure(background="#ececec")
        self.btnRec.configure(cursor="hand2")
        self.btnRec.configure(disabledforeground="#a3a3a3")
        self.btnRec.configure(font=('Bahnschrift', 10))
        self.btnRec.configure(foreground="#000000")
        self.btnRec.configure(highlightbackground="#ececec")
        self.btnRec.configure(highlightcolor="black")
        self.btnRec.configure(pady="0")
        self.btnRec.configure(text='''Record''')
        self.btnRec.configure(state=tk.DISABLED)
        self.btnRec_tooltip = \
            ToolTip(self.btnRec, self.tooltip_font, '''Start logging the data to a file.''')

        self.btnStop = tk.Button(self.Topbar)
        self.btnStop.place(relx=0.102, rely=0.139, height=50, width=50)
        self.btnStop.configure(activebackground="#d0d0d0")
        self.btnStop.configure(activeforeground="#000000")
        self.btnStop.configure(background="#ececec")
        self.btnStop.configure(cursor="hand2")
        self.btnStop.configure(disabledforeground="#a3a3a3")
        self.btnStop.configure(font=('Bahnschrift', 10))
        self.btnStop.configure(foreground="#000000")
        self.btnStop.configure(highlightbackground="#ececec")
        self.btnStop.configure(highlightcolor="black")
        self.btnStop.configure(pady="0")
        self.btnStop.configure(text='''Stop''')
        self.btnStop.configure(state=tk.DISABLED)
        self.btnStop_tooltip = \
            ToolTip(self.btnStop, self.tooltip_font, '''Stop the system, and reset the dashboard.''')

        self.btnOpenLogs = tk.Button(self.Topbar)
        self.btnOpenLogs.place(relx=0.945, rely=0.139, height=50, width=50)
        self.btnOpenLogs.configure(activebackground="#d0d0d0")
        self.btnOpenLogs.configure(activeforeground="#000000")
        self.btnOpenLogs.configure(background="#ececec")
        self.btnOpenLogs.configure(cursor="hand2")
        self.btnOpenLogs.configure(disabledforeground="#a3a3a3")
        self.btnOpenLogs.configure(font=('Bahnschrift', 10))
        self.btnOpenLogs.configure(foreground="#000000")
        self.btnOpenLogs.configure(highlightbackground="#ececec")
        self.btnOpenLogs.configure(highlightcolor="black")
        self.btnOpenLogs.configure(pady="0")
        self.btnOpenLogs.configure(text='''Open log''')
        self.btnOpenLogs.configure(state=tk.DISABLED)
        self.btnRec_tooltip = \
            ToolTip(self.btnRec, self.tooltip_font, '''Open the selected log file in a new window.''')

        # Unused button for now.
        # self.btnSettings = tk.Button(self.Topbar)
        # self.btnSettings.place(relx=0.945, rely=0.139, height=50, width=50)
        # self.btnSettings.configure(activebackground="#d0d0d0")
        # self.btnSettings.configure(activeforeground="#000000")
        # self.btnSettings.configure(background="#ececec")
        # self.btnSettings.configure(cursor="hand2")
        # self.btnSettings.configure(disabledforeground="#a3a3a3")
        # self.btnSettings.configure(font=('Bahnschrift', 10))
        # self.btnSettings.configure(foreground="#000000")
        # self.btnSettings.configure(highlightbackground="#ececec")
        # self.btnSettings.configure(highlightcolor="black")
        # self.btnSettings.configure(pady="0")
        # self.btnSettings.configure(text='''Settings''')
        # self.btnSettings.configure(state=tk.DISABLED)

        self.buttons_dict = {'stop': self.btnStop,
                             'play': self.btnPlay,
                             'pause': self.btnPause,
                             'record': self.btnRec,
                             # 'settings': self.btnSettings,
                             'openlogs': self.btnOpenLogs}

        self.btnPlay.configure(command=lambda: gui_support.play(self.buttons_dict))
        self.btnPause.configure(command=lambda: gui_support.pause(self.buttons_dict))
        self.btnStop.configure(command=lambda: gui_support.stop(self.buttons_dict))
        self.btnRec.configure(command=lambda: gui_support.record(self.buttons_dict))
        self.btnOpenLogs.configure(command=lambda: create_second_window(self.log_list_widget.selection()))
        # self.btnSettings.configure(command=gui_support.settings)

        self.cancel = self.Topbar.after(15000, self.check_if_loading)
        self.overlay = overlay_window()
        self.create_matplotlib_figures()
        self.init_table()
        self.update_loglist()
        self.update_table()
        self.set_webcam()
        self.set_description()
        # Create the overlay inside the mainwindow class so it has access to the created plots.


        keyboard.add_hotkey('ctrl+F6', self.bring_window_forward)  # Make the dashboard visible anywhere.
        keyboard.add_hotkey('ctrl+F7', gui_support.record, args=(self.buttons_dict,))  # Toggles recording
        keyboard.add_hotkey('ctrl+F8', self.overlay.toggle)  # Toggles overlay

    def bring_window_forward(self):
        shared.window_root.attributes('topmost', True)
        shared.window_root.attributes('topmost', False)

    def set_description(self):
        current_time = datetime.datetime.now()
        if shared.logger.start_time == 0:
            duration = 0
        else:
            seconds = (current_time - shared.logger.start_time).total_seconds()
            duration = shared.logger.seconds_to_HMS(seconds)

        self.description['Time'] = current_time.strftime("%H:%M:%S")
        self.description['Duration'] = str(duration)
        self.description['Overlay'] = str(self.overlay.visible)

        # Read as: "<key>:  <value>" if key is not empty, otherwise "<value>".
        descToLines = ["{0}{1}{2}".format(key if key != '' else '', ':\t' if key != '' else '', val) for key, val in
                       self.description.items()]
        linesToString = "\n".join(["{0}".format(line) for line in descToLines])
        self.msgDescription.configure(text=linesToString)
        self.msgDescription.after(1000, self.set_description)

    def set_webcam(self):
        if shared.webcam_image is not None:
            self.webcamViewLabel.configure(image=shared.webcam_image)
            self.webcamViewLabel.after(10, self.set_webcam)
        else:
            self.webcamViewLabel.after(1000, self.set_webcam)

    def check_if_loading(self):
        state = shared.system_state
        if state != shared.State.LOADING:
            self.Topbar.after_cancel(self.cancel)
            gui_support.stop(
                self.buttons_dict)  # Simulate the a press of the stop button. Unlock buttons and keep face rec off.
        else:
            self.cancel = self.Topbar.after(3000, self.check_if_loading)

    # def setWordcloudColors(self, word, font_size, position, orientation, random_state=None, **kwargs):
    #     '''Returns the HSL color value from dict 'hsl' for WordCloud.'''
    #     return shared.hsl[word]

    def create_matplotlib_figures(self):
        # It is more efficient for some reason to setup the axes here, than to use FuncAnimation's "init_func" way.
        self.bar_ax.bar([i + 1 for i in range(7)], [50 for _ in range(7)], color=shared.all_colors)  # Initial values.
        self.bar_ax.set_xticks([i + 1 for i in range(7)], minor=False)
        self.bar_ax.set_xticklabels(shared.emotion_names, fontdict=None, minor=False)
        self.bar_ax.set_ylabel('Confidence level (%)')
        self.bar_ax.set_xlabel('Emotions')
        self.bar_ax.set_ylim([0, 100])
        self.bar_ax.yaxis.set_major_locator(MultipleLocator(20))
        self.bar_ax.yaxis.set_major_formatter(FormatStrFormatter('%d%%'))
        self.bar_ax.yaxis.set_minor_locator(MultipleLocator(5))
        canvas = FigureCanvasTkAgg(self.bar_fig, self.fBars)
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()
        # Create the animation to refresh the bar chart.
        self.ani_bar = animation.FuncAnimation(fig=self.bar_fig, func=self.update_bar, interval=200)

        # Wordcloud
        # canvas = FigureCanvasTkAgg(self.cloud_fig, self.fWordcloud)
        # canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        # canvas.draw()
        # Create the animation to refresh the word cloud.
        # self.ani_cloud = animation.FuncAnimation(fig=self.cloud_fig, func=self.update_word_cloud, interval=1000)

    def update_bar(self, i):
        if shared.system_state == shared.State.ACTIVE:
            for bar in self.bar_ax.containers:
                bar.remove()  # Essentially clear, without destroying the axes!
            self.bar_ax.bar(x=[1, 2, 3, 4, 5, 6, 7], height=[i * 100.0 for i in shared.current_prediction],
                            color=shared.all_colors)
        elif shared.system_state == shared.State.STOPPED and shared.previous_system_state != shared.State.STOPPED:
            shared.previous_system_state = shared.State.STOPPED
            # The system was just stopped.
            print('Resetting')
            self.update_loglist()
            shared.reset()
            self.update_table(reset=True)

    # def update_word_cloud(self, i):
    #     if shared.system_state == shared.State.ACTIVE:
    #         emotion_freq = {}
    #         for i, val in shared.emotion_dict.items():  # Probably not the best practice...
    #             if val != 'Neutral':
    #                 emotion_freq[val] = shared.total_predictions[i] + 1  # Avoid problems with everything being 0
    #         wordcloud = WordCloud(max_font_size=30, background_color="white",
    #                               color_func=self.setWordcloudColors, prefer_horizontal=1.0, stopwords={})
    #
    #         wordcloud.random_state = Random(1)  # Fix the seed so that words don't jump around.
    #         wordcloud.fit_words(emotion_freq)
    #
    #         self.cloud_ax.imshow(wordcloud, interpolation='bilinear')
    #         self.cloud_ax.axis('off')w

    def init_table(self):
        # Confirmed working.
        for i in range(7):
            self.table.insert(parent='', index='end', iid=shared.emotion_names[i], text=shared.emotion_names[i],
                              values='0')

    def update_table(self, reset=False):
        emotion_names = list(shared.emotion_dict.values())
        # if not reset:
        emotion_total = shared.total_predictions
        sum = np.sum(emotion_total)
        sum = sum if sum != 0 else 1
        percentages = np.around(emotion_total / sum * 100.0, decimals=1)
        for i in range(7):
            self.table.item(item=emotion_names[i], values='{}%'.format(percentages[i]))
        # else:
        #     for i in range(7):
        #         self.table.item(item=emotion_names[i], values='0')
        self.table.after(1000, self.update_table)

    def update_loglist(self):
        # Create a list of log dicts, each containing all data in existing log files.
        temp = [log_filename for log_filename in os.listdir('logs') \
                if os.path.isfile(os.path.join('logs', log_filename))]
        if self.log_list != temp:
            self.log_list = temp

            for dir in self.log_list:
                log_contents = shared.logger.read(dir)
                if log_contents is not None:
                    try:
                        self.log_list_widget.insert('', 'end', iid=dir, text=log_contents['date'], \
                                                    values=(log_contents['time'], log_contents['duration']))
                    except:  # Item already exists
                        pass


def create_second_window(selected_sessions):
    if len(selected_sessions) == 1:
        sec_win = second_window(selected_sessions[0])


class second_window(tk.Toplevel):

    def __init__(self, log_name):
        tk.Toplevel.__init__(self)
        self.log_name = log_name
        root_dir = os.path.dirname(os.path.realpath(__file__))  # Root folder.
        self.image_folder_path = os.path.join(root_dir, 'logs\\{}'.format(log_name)[:-4])  # Take off '.csv'
        self.log = shared.logger.read(log_name)  # Could be NoneType

        self.image_cache = {}

        self.geometry("1280x720+383+198")
        # self.win.minsize(120, 1)
        # self.win.maxsize(3844, 1061)
        self.resizable(0, 0)
        self.title(log_name)
        self.configure(background="#d9d9d9")
        self.configure(highlightbackground="#d9d9d9")
        self.configure(highlightcolor="black")

        # Automatically generated
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'

        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.configure('.', font="TkDefaultFont")
        self.style.map('.', background= [('selected', _compcolor), ('active', _ana2color)])

        # ____________________________________________________

        self.states = {
            'Angry': True,
            'Disgusted': True,
            'Fearful': True,
            'Happy': True,
            'Neutral': True,
            'Sad': True,
            'Surprised': True
        }

        # TOP MENU
        self.topbar = tk.Frame(self)
        self.topbar.place(relx=0.0, rely=0.0, relheight=0.1, relwidth=1.0)
        self.topbar.configure(highlightbackground="#f0f0f0f0f0f0")
        self.topbar.configure(highlightcolor="black")
        self.topbar.configure(relief='groove')
        self.topbar.configure(background="#ffffff")

        self.header = tk.Label(self.topbar)
        self.header.place(relx=0, rely=0, relwidth=1.0, relheight=1.0)
        self.header.configure(font=('Bahnschrift', 12))
        self.header.configure(background="#ffffff")

        # PIE CHARTS
        self.fPie = tk.Frame(self)
        self.fPie.place(relx=0, rely=0.1, relwidth=0.5, relheight=0.4)
        self.fPie.configure(background="#ffffff")

        # LINE CHART
        self.fLine = tk.Frame(self)
        self.fLine.place(relx=0, rely=0.55, relwidth=1.0, relheight=0.45)
        self.fLine.configure(background="#ffffff")

        # BUTTON CONTAINER
        self.fLineButtons = tk.Frame(self)
        self.fLineButtons.place(relx=0, rely=0.5, relwidth=1.0, relheight=0.05)
        self.fLineButtons.configure(background="#ffffff")
        self.fLineButtons.configure(padx=20)
        self.fLineButtons.configure(pady=5)

        # EMOTION FILTER BUTTONS
        self.buttons = {}
        for i, emotion in enumerate(self.states.keys()):
            self.buttons[emotion] = tk.Button(self.fLineButtons, command=lambda emotion=emotion: self.toggle(emotion))
            self.buttons[emotion].configure(text=emotion)
            self.buttons[emotion].configure(activebackground="#d0d0d0")
            self.buttons[emotion].configure(activeforeground="#000000")
            self.buttons[emotion].configure(background="#ececec")
            self.buttons[emotion].configure(cursor="hand2")
            self.buttons[emotion].configure(disabledforeground="#a3a3a3")
            self.buttons[emotion].configure(font=('Bahnschrift', 12))
            self.buttons[emotion].configure(foreground="#000000")
            self.buttons[emotion].configure(highlightbackground="#ececec")
            self.buttons[emotion].configure(highlightcolor="black")
            self.buttons[emotion].configure(pady="0")
            self.buttons[emotion].place(x=i * 100, rely=0, width=80, relheight=0.9)
            self.buttons[emotion].configure(relief=tk.SUNKEN)  # Default state is pressed.

        self.fApp = tk.Frame(self)
        self.fApp.place(relx=0.5, rely=0.1, relwidth=0.5, relheight=0.4)
        self.fApp.configure(background="#ffffff")
        self.lAppImg = tk.Label(self.fApp)
        self.lAppImg.configure(background="#ffffff")
        self.lAppImg.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)

        self.header.configure(text='Showing {}'.format(self.log['date'] + self.log['time']))
        self.set_pie_chart()
        self.set_line_chart()

    def change_line_data(self):
        data = self.clean_data  # Dictionary with all data points separated per emotion.
        enabled_emotions = [emotion for emotion, state in self.states.items() if state]
        stacked_data = []

        stacked_data = [val if key in enabled_emotions else [] for key, val in data.items()]
        # Same as:
        # for key,val in data.items():
        #     if key in enabled_emotions:
        #         stacked_data.append(val)
        #     else:
        #         stacked_data.append([])

        for bar in self.line_ax.collections:
            bar.remove()  # Essentially clear, without destroying the axes!
        self.line_ax.eventplot(stacked_data, orientation='horizontal', color=shared.all_colors, linewidths=5)
        self.line_canvas.draw()

    def toggle(self, emotion):
        print(emotion)
        new_state = not self.states[emotion]
        self.states[emotion] = new_state
        if new_state:
            self.buttons[emotion].config(relief=tk.SUNKEN)
        else:
            self.buttons[emotion].config(relief=tk.RAISED)
        self.change_line_data()

    def set_pie_chart(self):
        self.pie_fig = Figure(dpi=100)
        self.pie_ax = self.pie_fig.add_subplot()
        corrected_totals = [i - 1 for i in self.log['totals']]  # Subtract 1 from each because of their initialisation.
        _, _, autotexts = self.pie_ax.pie(corrected_totals, autopct='%1.1f%%', colors=shared.all_colors, shadow=True)
        for autotext in autotexts:
            autotext.set_color('white')  # Set the percentages inside the chart to white.
        self.pie_ax.legend(shared.emotion_names)
        self.pie_ax.axis('equal')
        self.pie_ax.set_title('Total distribution of recorded emotions', fontsize=12)

        canvas = FigureCanvasTkAgg(self.pie_fig, self.fPie)
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        canvas.draw()

    def set_line_chart(self):
        self.line_fig = Figure(figsize=(12.8, 2.9), dpi=100)
        self.line_ax = self.line_fig.add_subplot()

        self.clean_data = {emotion: [] for emotion in shared.emotion_names}  # Create 7 empty lists for each emotion.
        timestamps = self.log['data']['timestamps'].astype(np.float)
        labels = self.log['data']['labels']

        for line in range(self.log['line_count']):
            time, emotion = timestamps[line], labels[line]
            emotion = emotion.strip()  # Remove any whitespaces before or after: ' Neutral' --> 'Neutral'.
            self.clean_data[emotion].append(time)

        # Now we have lists for each emotion, with timestamps when each emotion was detected.
        # These are then stacked on top of each other so they can into eventplot in one go.
        stacked_data = [val for key, val in self.clean_data.items()]

        self.line_ax.eventplot(stacked_data, orientation='horizontal', color=shared.all_colors, linewidths=5)

        duration_string = self.log['duration'].strip()  # String like "HH:MM:SS"
        h, m, s = [round(float(x), 2) for x in duration_string.split(':')]
        duration = h * 3600 + m * 60 + s

        if duration <= 60:  # 1 minute or less
            major_multiple = 5
            minor_multiple = 1
        elif duration <= 600:  # 10 minutes or less
            major_multiple = 60
            minor_multiple = 10
        elif duration <= 3600:  # 60 minutes or less
            major_multiple = 300
            minor_multiple = 60
        self.line_ax.xaxis.set_major_locator(plt.MultipleLocator(major_multiple))
        self.line_ax.xaxis.set_minor_locator(plt.MultipleLocator(minor_multiple))
        self.line_ax.yaxis.set_major_formatter(FormatStrFormatter('%d'))
        self.line_ax.set_title('Recorded emotions over time', fontsize=12)

        # Crop the plot in the x-direction and y-direction and add the names.
        self.line_ax.axes.set_xlim([-0.1, None])  # Let the plot figure out its end point.
        self.line_ax.axes.set_ylim([-1, 7])
        self.line_ax.set_yticks([i for i in range(7)], minor=False)
        self.line_ax.set_yticklabels(shared.emotion_names, fontdict=None, minor=False)

        # self.line_fig.tight_layout()

        self.line_canvas = FigureCanvasTkAgg(self.line_fig, self.fLine)
        self.line_canvas.draw()

        # Enable the toolbar
        toolbar = NavigationToolbar2Tk(self.line_canvas, self.fLine)
        toolbar.update()
        self.line_canvas.get_tk_widget().pack()

        self.cid = self.line_fig.canvas.mpl_connect('button_press_event', self.on_click)

    def on_click(self, event):
        time = event.xdata
        img_name = str(self.closest_datapoint(time)) + '.jpg'  # Should be made an argument somehow.
        if img_name in self.image_cache:
            img = self.image_cache[img_name]
        else:
            img_path = os.path.join(self.image_folder_path, img_name)
            img = Image.open(img_path)
            rescaled_img = img.resize((512, 288), Image.BILINEAR)
            img = ImageTk.PhotoImage(rescaled_img)
            self.image_cache[img_name] = img
        self.lAppImg.configure(image=img)

    def closest_datapoint(self, time):
        # Find the smallest error between time and all data points.
        timestamps = self.log['data']['timestamps']
        dist_squared = (timestamps - time) ** 2  # Vector of distances between all points and the clicked point.
        closest = timestamps[np.argmin(dist_squared)]
        return closest


from time import time, localtime, strftime


class ToolTip(tk.Toplevel):
    """
    Provides a ToolTip widget for Tkinter.
    To apply a ToolTip to any Tkinter widget, simply pass the widget to the
    ToolTip constructor
    """

    def __init__(self, wdgt, tooltip_font, msg=None, msgFunc=None,
                 delay=0.5, follow=True):
        """
        Initialize the ToolTip

        Arguments:
          wdgt: The widget this ToolTip is assigned to
          tooltip_font: Font to be used
          msg:  A static string message assigned to the ToolTip
          msgFunc: A function that retrieves a string to use as the ToolTip text
          delay:   The delay in seconds before the ToolTip appears(may be float)
          follow:  If True, the ToolTip follows motion, otherwise hides
        """
        self.wdgt = wdgt
        # The parent of the ToolTip is the parent of the ToolTips widget
        self.parent = self.wdgt.master
        # Initalise the Toplevel
        tk.Toplevel.__init__(self, self.parent, bg='black', padx=1, pady=1)
        # Hide initially
        self.withdraw()
        # The ToolTip Toplevel should have no frame or title bar
        self.overrideredirect(True)

        # The msgVar will contain the text displayed by the ToolTip
        self.msgVar = tk.StringVar()
        if msg is None:
            self.msgVar.set('No message provided')
        else:
            self.msgVar.set(msg)
        self.msgFunc = msgFunc
        self.delay = delay
        self.follow = follow
        self.visible = 0
        self.lastMotion = 0
        # The text of the ToolTip is displayed in a Message widget
        tk.Message(self, textvariable=self.msgVar, bg='#FFFFDD',
                   font=tooltip_font,
                   aspect=1000).grid()

        # Add bindings to the widget.  This will NOT override
        # bindings that the widget already has
        self.wdgt.bind('<Enter>', self.spawn, '+')
        self.wdgt.bind('<Leave>', self.hide, '+')
        self.wdgt.bind('<Motion>', self.move, '+')

    def spawn(self, event=None):
        """
        Spawn the ToolTip.  This simply makes the ToolTip eligible for display.
        Usually this is caused by entering the widget

        Arguments:
          event: The event that called this funciton
        """
        self.visible = 1
        # The after function takes a time argument in milliseconds
        self.after(int(self.delay * 1000), self.show)

    def show(self):
        """
        Displays the ToolTip if the time delay has been long enough
        """
        if self.visible == 1 and time() - self.lastMotion > self.delay:
            self.visible = 2
        if self.visible == 2:
            self.deiconify()

    def move(self, event):
        """
        Processes motion within the widget.
        Arguments:
          event: The event that called this function
        """
        self.lastMotion = time()
        # If the follow flag is not set, motion within the
        # widget will make the ToolTip disappear
        #
        if self.follow is False:
            self.withdraw()
            self.visible = 1

        # Offset the ToolTip 10x10 pixes southwest of the pointer
        self.geometry('+%i+%i' % (event.x_root + 20, event.y_root - 10))
        try:
            # Try to call the message function.  Will not change
            # the message if the message function is None or
            # the message function fails
            self.msgVar.set(self.msgFunc())
        except:
            pass
        self.after(int(self.delay * 1000), self.show)

    def hide(self, event=None):
        """
        Hides the ToolTip.  Usually this is caused by leaving the widget
        Arguments:
          event: The event that called this function
        """
        self.visible = 0
        self.withdraw()

    def update(self, msg):
        """
        Updates the Tooltip with a new message. Added by Rozen
        """
        self.msgVar.set(msg)
